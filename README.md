# Theoretical Background

## Memory Management and the MMU
Modern operating systems use virtual memory to provide each process with the illusion of a large, private address space, even if the physical memory (RAM) is much smaller. The **Memory Management Unit (MMU)** is a hardware component responsible for translating virtual addresses generated by programs into physical addresses in RAM. This translation allows processes to run in isolation and enables features like memory protection and efficient multitasking.

## Pages, Frames, and Page Tables
- **Pages**: Virtual memory is divided into fixed-size blocks called pages (commonly 4096 bytes). Each process sees its own set of virtual pages.
- **Frames**: Physical memory is divided into blocks of the same size, called frames. Pages are loaded into frames as needed.
- **Page Table**: The operating system maintains a page table for each process. This table maps virtual page numbers to physical frame numbers. When a process accesses a memory address, the MMU uses the page table to find the corresponding frame. If the page is not present in memory (a situation called a **page fault**), the OS must load it from disk, possibly evicting another page if memory is full.
- **Page Faults**: When a program accesses a page that is not currently in physical memory, a page fault occurs. The OS must then load the required page from disk into a free frame (or evict an existing page if all frames are occupied).

## Page Replacement Algorithms
When physical memory is full and a new page needs to be loaded, the OS must decide which page to evict. The choice of page replacement algorithm can significantly affect system performance. Two common algorithms are:
- **LRU (Least Recently Used)**: This algorithm evicts the page that has not been used for the longest time, based on the assumption that pages used recently will likely be used again soon. LRU requires tracking the usage order of pages, which can be costly in hardware but is often simulated in software.
- **Second Chance**: This is a practical approximation of LRU. Each page has a reference bit. When a page is considered for eviction, if its reference bit is set, it is cleared and the page is given a 'second chance.' The algorithm cycles through pages until it finds one with a cleared reference bit, which is then evicted. This reduces overhead compared to true LRU while still favoring recently used pages.

## Simulation Purpose
This project simulates the above mechanisms, allowing experimentation with different page replacement strategies and providing insight into their impact on system performance. By using real memory access traces, the simulator models how different algorithms affect the number of page faults, disk reads/writes, and overall efficiency. This helps students and researchers understand the trade-offs involved in memory management design.

# Memory Management Simulator

## Overview
This project is a memory management simulator for Operating Systems, written in C/C++. It simulates how a system manages memory using real memory access traces and implements two page replacement algorithms: **LRU (Least Recently Used)** and **Second Chance**.

## Features
- Reads two trace files (`bzip.trace` and `gcc.trace`), each containing memory references (hex addresses + R/W).
- Simulates virtual memory using a hashed page table to track loaded pages.
- Implements LRU and Second Chance algorithms for page replacement.
- Alternates reading batches (q references) from each trace file, so both processes have pages in memory.
- Tracks statistics: disk reads/writes, page faults, total references processed, and number of memory frames.
- Command-line arguments:
  - Algorithm (`lru` or `secondChance`)
  - Number of memory frames
  - Batch size `q`
  - Maximum number of references to process (or `-1` for all)

## Data Structures
- **Hash tables:** Store pages loaded in memory, using linked lists of `hashnode` structs.
- **Memory frames:** Array of `memoryFrame` structs, each pointing to a `hashnode` and tracking if the page is dirty (needs to be written to disk).

## Main Flow
1. Initialize hash tables and memory frames.
2. Open trace files and read `q` references alternately from each.
3. For each reference:
   - Extract page number (20 bits) and offset (12 bits).
   - Check if the page is in memory (hash table).
   - If not, handle page fault, possibly evict a page using the selected algorithm, and update statistics.
   - If evicted page is dirty, increment write counter.
   - If reference is a write, set dirty bit.
   - For Second Chance, periodically reset reference bits.
4. After all references: Write back any remaining dirty pages, free memory, and print statistics.

## Example Usage
```
./simulator lru 100 250 20000
```
Runs the simulator with LRU, 100 frames, batches of 250 references, and a max of 20,000 references.

## Compilation
Use the provided Makefile:
```
make
```

## Files
- `Simulator.c`: Main program logic and simulation loop.
- `PageTable.c`: Hash table and page table management.
- `MemoryStructure.c`: Memory frame management and replacement algorithms.
- `Makefile`: Build instructions.
- `bzip.trace`, `gcc.trace`: Input trace files (download from assignment links).

## Statistics Reported
- Number of disk reads
- Number of disk writes
- Number of page faults
- Number of references processed
- Number of memory frames used